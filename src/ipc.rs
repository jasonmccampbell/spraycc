extern crate byteorder;
extern crate bytes;
extern crate tokio;

use byteorder::{BigEndian, ByteOrder};
use bytes::{Buf, BytesMut};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt;
use std::hash::{Hash, Hasher};
use std::path::PathBuf;
use std::time;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpStream;

/// Error returned by most functions.
///
/// When writing a real application, one might want to consider a specialized
/// error handling crate or defining an error type as an `enum` of causes.
/// However, for our example, using a boxed `std::error::Error` is sufficient.
///
/// For performance reasons, boxing is avoided in any hot path. For example, in
/// `parse`, a custom error `enum` is defined. This is because the error is hit
/// and handled during normal execution when a partial frame is received on a
/// socket. `std::error::Error` is implemented for `parse::Error` which allows
/// it to be converted to `Box<dyn std::error::Error>`.
pub type Error = Box<dyn std::error::Error + Send + Sync>;

/// A specialized `Result` type defined as a convenience.
pub type Result<T> = std::result::Result<T, Error>;

/// The host and port to connect to and the access code to use
#[derive(Serialize, Deserialize, Debug)]
pub struct CallMe {
    pub addr: std::net::SocketAddr,
    pub access_code: u64,
}

//
// Catalog of messages used in the system
//

/// Type of output generated by a task, either standard IO or zero or more files written by the process
#[derive(PartialEq, Eq, Hash, Copy, Clone, Serialize, Deserialize, Debug)]
pub enum OutputType {
    Stdout,
    Stderr,
    File(usize),
}

/// Describes the task to be started on a remote host
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub struct TaskDetails {
    /// Directory in which to run the command
    pub working_dir: PathBuf,
    /// Absolute path to the command to be executes
    pub cmd: PathBuf,
    /// Set of arguments to be passed to the command
    pub args: Vec<String>,
    /// Indices into 'args' which are output file names to be captured and relayed back to the originating host
    pub output_args: Vec<u16>,
    /// Environment variables to be propagated to the execution host
    pub env: HashMap<String, String>,
    /// Hint that the task should be given high priority relative to other tasks. Ex: dependency generation
    /// tasks which must complete before others can start.
    pub priority_task: bool,
}

impl TaskDetails {
    /// Returns an ID string expected (but not guananteed) to be unique across all tasks for
    /// a given run. In practice, if there are output targets, the string is a concatenation of
    /// all of these. If no output targets are present, then it is the CWD plus all arguments.
    ///
    /// Currently the output targets do _not_ include the CWD, relative or absolute. This means
    /// two workspaces for the same project will have collisions for the same output target
    /// (same .o files). This is intended since the elapsed times should normally be reuable,
    /// but it remains to be seen if this is true in practice.
    pub fn get_target_id(self: &TaskDetails) -> String {
        if self.output_args.is_empty() {
            let mut s = self.working_dir.to_string_lossy().to_string();
            self.args.iter().for_each(|arg| {
                s.push(';');
                s.push_str(arg)
            });
            s
        } else if self.output_args.len() == 1 {
            self.args[self.output_args[0] as usize].clone()
        } else {
            // TODO: In the case of multiple output files do we sort the names?
            self.output_args
                .iter()
                .map(|i| self.args[*i as usize].as_str())
                .collect::<Vec<&str>>()
                .join(";")
        }
    }
}

impl Hash for TaskDetails {
    /// Hash is required for the priority queue. The output args aren't needed because the same
    /// information in encoded in 'args'. 'env' is not included because it is expensive and one would
    /// hope two tasks don't differ only in the captured environment.
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.working_dir.hash(state);
        self.cmd.hash(state);
        self.args.hash(state);
    }
}

/// Messages sent between Spraycc processes.
/// *C++*: This could be done as a trait (interface / base class) or as an enum (enum + struct). A trait
/// would be more common in open systems so set of messages can be extened without requiring a
/// recompile of the whole system (any module can add a new implementation of the interface). I went with
/// an enum here becaause it's a closed system with a small set of messages so it's nice to have the compiler
/// validate that every message type is handled. And it's a way to experiment with Rust enum's.
#[derive(Serialize, Deserialize, Clone)]
pub enum Message {
    /// Executor is ready, sends access code
    YourObedientServant {
        access_code: u64,
    },

    /// Task defintion, from wrapper to server or server to executable. When sent to an executor the
    /// access code is ignored.
    Task {
        access_code: u64,
        details: TaskDetails,
    },

    /// Output from a task from exec to server, possibly to wrapper
    TaskOutput {
        output_type: OutputType,
        content: Vec<u8>,
    },

    // A task failed to even start
    TaskFailed {
        error_message: String,
    },

    // Task has finished, all output has been sent. When reeived by the wrapper, the wrapper
    // process should disconnect and exit. A 'None' for the exit code means it was terminated by a signal.
    TaskDone {
        /// Task exit status: 0 == success, > 0 error code, < 0 exited with signal. None indicates task failed to stard
        exit_code: Option<i32>,
        /// Target ID of the task which just completed
        target_id: String,
        /// Runtime of the task itself
        run_time: time::Duration,
        /// Time requires to send back the results
        send_time: time::Duration,
    },

    // A specific task should be canceled
    CancelTask,

    /// Executor can (must) terminate, killing any job running
    PissOff,

    /// A connection was dropped, sent from the connection to the local event loop
    Dropped,
}

/// Normally would be automatically derived, but I don't want to dump the buffer contents. Is there a way
/// to derive everything else without having to implement all of this?
impl fmt::Debug for Message {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Message::YourObedientServant { access_code } => write!(f, "YourObedientServant: {}", access_code),
            Message::Task { access_code, details } => write!(f, "Task: code {}, details: {:?}", access_code, details),
            Message::TaskOutput { output_type, content } => match output_type {
                OutputType::Stderr => {
                    let x = String::from_utf8(content.clone()).unwrap();
                    write!(f, "TaskOutput {:?}, length {}: {}", output_type, x.len(), x)
                }
                _ => write!(f, "TaskOutput {:?}, length {}", output_type, content.len()),
            },
            Message::TaskFailed { error_message } => write!(f, "TaskDone, error: {}", error_message),
            Message::TaskDone {
                exit_code,
                target_id,
                run_time,
                send_time,
            } => write!(
                f,
                "TaskDone, {}: exit code {}, runtime {}, {}",
                target_id,
                exit_code.unwrap_or(-1),
                run_time.as_secs_f64(),
                send_time.as_secs_f64()
            ),
            Message::CancelTask => write!(f, "CancelTask"),
            Message::PissOff => write!(f, "PissOff"),
            Message::Dropped => write!(f, "Dropped"),
        }
    }
}

pub struct Connection {
    stream: TcpStream,
    buf: BytesMut, // Buffer sizes based on 'size', may be incomplete
}

impl Connection {
    pub fn new(stream: TcpStream) -> Connection {
        Connection {
            stream,
            buf: BytesMut::with_capacity(65536 * 4096), // Max msg size + 1 page
        }
    }

    /// Returns the next message from the stream or None if the stream has closed. An error is returned
    /// if the stream returns EOF while reading a partial message.
    pub async fn read_message(&mut self) -> Result<Option<Message>> {
        // Each message starts with the message length. A disconnect with 0 bytes read is a normal
        // stream-close event. An EOF with bytes in the buffer is an unexpected reset.
        while self.buf.len() < 4 {
            if self.stream.read_buf(&mut self.buf).await? == 0 {
                return if self.buf.is_empty() {
                    Ok(None)
                } else {
                    Err(format!("Connection reset by peer with {} bytes buffered", self.buf.len()).into())
                };
            }
        }
        let msg_size = self.buf.get_i32() as usize;

        // Keep reading until we have at least a full message
        while self.buf.len() < msg_size && self.stream.read_buf(&mut self.buf).await? > 0 {}

        // May get more than a full message, that is ok. A partial message indicates that the connection
        // was broken prematurely.
        if self.buf.len() >= msg_size {
            // TODO: This could panic if garbage comes in. bincode have a non-panic mechanism?
            let msg = bincode::deserialize(self.buf.as_ref()).expect("Unable to decode message");
            self.buf.advance(msg_size);
            Ok(Some(msg))
        } else {
            Err(format!("connection reset by peer {} {}", self.buf.len(), msg_size).into())
        }
    }

    pub async fn write_message(&mut self, msg: &Message) -> Result<()> {
        let data: Vec<u8> = bincode::serialize(&msg).unwrap();
        let mut sz = [0; 4];

        BigEndian::write_u32(&mut sz, data.len() as u32);
        self.stream.write_all(&sz).await?;
        self.stream.write_all(&data).await?;
        Ok(())
    }

    pub async fn flush(&mut self) -> Result<()> {
        self.stream.flush().await?;
        Ok(())
    }

    pub async fn shutdown(&mut self) {
        let _ = self.stream.shutdown().await;
    }
}

#[cfg(test)]
use std::net::SocketAddr;
#[cfg(test)]
use tokio::net::TcpListener;
#[cfg(test)]
use tokio::time::Duration;

// Test sending / receiving messages
#[tokio::test]
async fn test_msgs() {
    fn vec_of_size(sz: usize) -> Vec<u8> {
        let mut v: Vec<u8> = Vec::new();
        v.resize(sz, 0);
        v
    }

    let addr: SocketAddr = "127.0.0.1:0".parse().unwrap();

    // Setup the server socket
    let server = TcpListener::bind(addr).await.unwrap();
    println!("Server listening on {:?}", server.local_addr());

    // Setup the client socket
    let client_sock = TcpStream::connect(server.local_addr().unwrap()).await.unwrap();
    println!("Connection ready");

    let (socket, _) = server.accept().await.unwrap();

    // Spawn a task to send the test message
    tokio::spawn(async move {
        let mut conn = Connection::new(client_sock);
        conn.write_message(&Message::YourObedientServant { access_code: 666 }).await.unwrap();
        conn.write_message(&Message::TaskDone {
            exit_code: Some(0),
            target_id: "".to_string(),
            run_time: Duration::from_secs(2),
            send_time: Duration::from_millis(15),
        })
        .await
        .unwrap();
        // A large message, greater than one package
        conn.write_message(&Message::TaskOutput {
            output_type: OutputType::File(1),
            content: vec_of_size(8192 * 16),
        })
        .await
        .unwrap();

        conn.write_message(&Message::PissOff {}).await.unwrap();
        tokio::time::sleep(Duration::from_secs(1)).await; // Hack, just make sure all of the messages get out
    });

    let mut conn = Connection::new(socket);
    let mut msgs_recvd = 0;
    loop {
        match next_message(&mut conn).await {
            Some(Message::PissOff) => {
                msgs_recvd += 1;
                break;
            }
            Some(_) => msgs_recvd += 1,
            None => break,
        }
    }
    conn.shutdown().await;
    assert_eq!(msgs_recvd, 4);
}

#[cfg(test)]
async fn next_message(conn: &mut Connection) -> Option<Message> {
    loop {
        match conn.read_message().await {
            Ok(Some(msg)) => return Some(msg),
            Err(_) => return None,
            Ok(None) => {} // Nothing ready yet
        }
    }
}

#[test]
fn test_task_details_target() {
    let wd = PathBuf::from("/an/absolute/dir");
    let cmd = PathBuf::from("/path/to/binary");
    let env = HashMap::<String, String>::new();

    let t1 = TaskDetails {
        working_dir: wd.clone(),
        cmd: cmd.clone(),
        args: vec!["-c", "-o", "objs/foo.o", "-I", "../include"]
            .iter()
            .map(|s| (**s).to_string())
            .collect(),
        output_args: vec![2u16],
        env: env.clone(),
    };
    let t1_target = t1.get_target_id();

    let t2 = TaskDetails {
        working_dir: wd.clone(),
        cmd: cmd.clone(),
        args: vec!["-c", "-MF", "objs/foo.d", "objs/foo.o", "-I", "../include"]
            .iter()
            .map(|s| (**s).to_string())
            .collect(),
        output_args: vec![2u16, 3u16],
        env: env.clone(),
    };
    let t2_target = t2.get_target_id();

    let t3 = TaskDetails {
        working_dir: wd.clone(),
        cmd: cmd.clone(),
        args: vec!["-c", "-I", "../include", "-O3", "-o", "objs/foo.o"]
            .iter()
            .map(|s| (**s).to_string())
            .collect(),
        output_args: vec![5u16],
        env: env.clone(),
    };
    let t3_target = t3.get_target_id();

    // No output arguments

    let t4 = TaskDetails {
        working_dir: wd.clone(),
        cmd: cmd.clone(),
        args: vec!["run_test", "-test-name", "test1"].iter().map(|s| (**s).to_string()).collect(),
        output_args: vec![],
        env: env.clone(),
    };
    let t4_target = t4.get_target_id();

    let t5 = TaskDetails {
        working_dir: wd.clone(),
        cmd: cmd.clone(),
        args: vec!["run_test", "-test_name", "test1", "--silent"]
            .iter()
            .map(|s| (**s).to_string())
            .collect(),
        output_args: vec![],
        env: env.clone(),
    };
    let t5_target = t5.get_target_id();

    let t6 = TaskDetails {
        working_dir: {
            let mut w = wd.clone();
            w.push("extra_path");
            w
        },
        cmd: cmd.clone(),
        args: vec!["run_test", "-test_name", "test1"].iter().map(|s| (**s).to_string()).collect(),
        output_args: vec![],
        env: env.clone(),
    };
    let t6_target = t6.get_target_id();

    println!("Targets: {}, {}, {}", &t1_target, &t2_target, &t3_target);
    println!("         {}, {}, {}", &t4_target, &t5_target, &t6_target);
    assert_ne!(t1_target, t2_target);
    assert_eq!(t1_target, t3_target);
    assert_ne!(t1_target, t4_target);
    assert_ne!(t4_target, t5_target);
    assert_ne!(t5_target, t6_target);
}
